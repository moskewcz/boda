# comparison test
boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-micro.txt --op-info-tab-fn=sgemm-info-tab.tex --op-eff-tab-fn=sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=nvrtc)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=4))' --use-culibs-comp=1 --use-culibs=0 --rtc-comp='(be=nvrtc)'


# cublas perf sweep
boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-small.txt --op-info-tab-fn=sgemm-info-tab.tex --op-eff-tab-fn=sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=nvrtc)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=4))' --use-culibs=1

# sweep using SD820 device:
boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-small.txt --op-info-tab-fn=SD820-sgemm-info-tab.tex --op-eff-tab-fn=SD820-sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=ipc,spawn_str=adb shell LD_LIBRARY_PATH=/data/local/lib /data/local/bin/boda,spawn_shell_escape_args=1,boda_parent_addr=tcp:10.0.0.100:12791)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=5))' --peak-flops=220e9 && cat SD820-sgemm-eff-tab.tex


# sweep using SD820 device (with cublas compare):
boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-small.txt --op-info-tab-fn=SD820-sgemm-info-tab.tex --op-eff-tab-fn=SD820-sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=ipc,spawn_str=adb shell LD_LIBRARY_PATH=/data/local/lib /data/local/bin/boda,spawn_shell_escape_args=1,boda_parent_addr=tcp:10.0.0.100:12791)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=5))' --peak-flops=220e9 --rtc-comp='(be=nvrtc)' --use-culibs-comp=1 --mad-toler=1e-3 && cat SD820-sgemm-eff-tab.tex
# TODO: investigate errors for 512 and 1024 sizes 

# test case for 512x512 case:
boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-debug.txt --op-info-tab-fn=SD820-sgemm-info-tab.tex --op-eff-tab-fn=SD820-sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=ipc,spawn_str=adb shell LD_LIBRARY_PATH=/data/local/lib /data/local/bin/boda,spawn_shell_escape_args=1,boda_parent_addr=tcp:10.0.0.100:12791)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=5))' --peak-flops=220e9 --rtc-comp='(be=ocl,gen_src=1)'  --mad-toler=1e-3 --max-err=10 && cat SD820-sgemm-eff-tab.tex 

# 512x512 test case with t-tile-sz=8, sgemm-bsz=16, and remote gen_src=1 set:
moskewcz@maaya:~/git_work/boda/run/tr1$ boda cnn_op_info --cnn-func-sigs-fn='%(boda_test_dir)'/sgemm-ops-debug.txt --op-info-tab-fn=SD820-sgemm-info-tab.tex --op-eff-tab-fn=SD820-sgemm-eff-tab.tex  --run-opt-variants=1 --rtc='(be=ipc,remote_rtc=(be=ocl,gen_src=1,gen_src_output_dir=/data/local/rtc-gen-src),spawn_str=adb shell LD_LIBRARY_PATH=/data/local/lib /data/local/bin/boda,spawn_shell_escape_args=1,boda_parent_addr=tcp:10.0.0.100:12791)' --gen-data='(type=foo,str_vals=(vi=0.0f,mode=600))' --peak-flops=220e9 --rtc-comp='(be=ocl,gen_src=1)'  --mad-toler=1e-3 --max-err=10 --t-tile-sz=8 --sgemm-bsz=16 && cat SD820-sgemm-eff-tab.tex 

# note: works on nvidia (ocl/nvrtc). fails on SD820. adding redundant index set fixes issue. 
# seems to be reading from bogus location in b[]. compiler bug? some undefined behavior that works on nVidia? hmm.

# magic props for SDP:
moskewcz@maaya:~$ adb shell getprop | grep cl
[debug.cl.enable.blocking]: [1]
[debug.cl.profiler]: [1]

# to clear blocking:
moskewcz@maaya:~$ adb shell setprop debug.cl.enable.blocking \'\'



sgemm__K_512__M_512__N_512__Mg_8__Ng_8__Mb_8__Nb_8__Kb_1__Mt_8__Nt_8 (no local memory version)

 Instruction stats
- All Instructions:      599,    1580 (rpt), ratio  2.64
- ALUs          :      289,     289 (rpt), ratio  1.00
- Total NOPs    :      282,    1053 (rpt), ratio  3.73
- NOPs          :       75,     432 (rpt), ratio  5.76
- Post-NOPs     :      207,     621 (rpt), ratio  3.00
- MOVs          :      146,     149 (rpt), ratio  1.02
- Loads/Stores  :       86,     148 (rpt), ratio  1.72
- ldp          :       16,      63 (rpt), ratio  3.94
- ldg          :        4,      16 (rpt), ratio  4.00
- stp          :        2,       5 (rpt), ratio  2.50
- stg          :       64,      64 (rpt), ratio  1.00
- Flow Instrs   :        3
- Short sync flags:       67
- Long sync flags :        7
- Full Registers  :       23
- uGPR Registers  :        4
- Unified Regs    :       23
- Scratch space   :      256
- Total footprint :      624
- Maximal Waves   :        2 (A5x)

sgemm__K_512__M_512__N_512__Mg_4__Ng_4__Mb_16__Nb_16__Kb_1__Mt_8__Nt_8 ( no local memory )

- Instruction stats
- All Instructions:      600,    1551 (rpt), ratio  2.59
- ALUs          :      291,     291 (rpt), ratio  1.00
- Total NOPs    :      276,    1019 (rpt), ratio  3.69
- NOPs          :       71,     408 (rpt), ratio  5.75
- Post-NOPs     :      205,     611 (rpt), ratio  2.98
- MOVs          :      148,     151 (rpt), ratio  1.02
- Loads/Stores  :       87,     148 (rpt), ratio  1.70
- ldp          :       17,      63 (rpt), ratio  3.71
- ldg          :        4,      16 (rpt), ratio  4.00
- stp          :        2,       5 (rpt), ratio  2.50
- stg          :       64,      64 (rpt), ratio  1.00
- Flow Instrs   :        3
- Short sync flags:       66
- Long sync flags :        7
- Full Registers  :       23
- uGPR Registers  :        4
- Unified Regs    :       23
- Scratch space   :      256
- Total footprint :      624
- Maximal Waves   :        2 (A5x)


using --t-tile-sz=8 --sgemm-bsz=16 --local-mem=0:

$128 \dx 128 \dx 128$ & \verb|sgemm| & 644us & 6.51GF/s & 2.96\\ 
$256 \dx 256 \dx 256$ & \verb|sgemm| & 1.29ms & 26.1GF/s & 11.8\\ 
$384 \dx 384 \dx 384$ & \verb|sgemm| & 5.49ms & 20.6GF/s & 9.38\\ 
$512 \dx 512 \dx 512$ & \verb|sgemm| & 10.5ms & 25.7GF/s & 11.7\\ 
$768 \dx 768 \dx 768$ & \verb|sgemm| & 33.0ms & 27.5GF/s & 12.5\\ 
$1024 \dx 1024 \dx 1024$ & \verb|sgemm| & 77.6ms & 27.7GF/s & 12.6\\ 
$1536 \dx 1536 \dx 1536$ & \verb|sgemm| & 254ms & 28.5GF/s & 13.0\\ 
$2048 \dx 2048 \dx 2048$ & \verb|sgemm| & 621ms & 27.7GF/s & 12.6\\ 

# initial version of sgemm_simd, basen on sgemm_no_local with vectorized global loads/stores

$128 \dx 128 \dx 128$ & \verb|sgemm_simd| & 255us & 16.4GF/s & 7.48\\ 
$256 \dx 256 \dx 256$ & \verb|sgemm_simd| & 511us & 65.7GF/s & 29.8\\ 
$384 \dx 384 \dx 384$ & \verb|sgemm_simd| & 2.10ms & 54.0GF/s & 24.5\\ 
$512 \dx 512 \dx 512$ & \verb|sgemm_simd| & 3.58ms & 75.1GF/s & 34.1\\ 
$768 \dx 768 \dx 768$ & \verb|sgemm_simd| & 11.5ms & 78.7GF/s & 35.8\\ 
$1024 \dx 1024 \dx 1024$ & \verb|sgemm_simd| & 27.8ms & 77.3GF/s & 35.1\\ 
$1536 \dx 1536 \dx 1536$ & \verb|sgemm_simd| & 88.4ms & 82.0GF/s & 37.3\\ 
$2048 \dx 2048 \dx 2048$ & \verb|sgemm_simd| & 219ms & 78.6GF/s & 35.7\\ 

# FIXME/TODO: track ocl backend version, and check local vs. remote version in rtc_ipc to avoid mismatch errors? not
  obvious how to do this usefully: (1) most changes to ocl_util.cc would require updating remote version, but how to we
  version one object file? hash of object post compilation? hash of source file? (2) if we track changes only to
  ocl_util.cc, what about changes to headers/etc that effect the behavior of ocl_util.cc (not relevant if we use
  binary/object versioning ...


